import subprocess
import os
import numpy as np

class SVDWrapper:
    def __init__(self, executable_path='./Singular_Value_Decomposition_SVD'):
        """
        Initialize the wrapper.
        
        Args:
            executable_path (str): Path to the compiled C++ executable.
        """
        self.executable_path = executable_path
        self.input_a = "A.dat"
        self.input_b = "B.dat"
        self.output_x = "X_out.dat"

    def compile(self):
        """
        Runs the 'make' command to compile the C++ program using the provided Makefile.
        """
        print("Compiling C++ code...")
        try:
            result = subprocess.run(['make'], capture_output=True, text=True, check=True)
            print("Compilation successful.")
            print(result.stdout)
        except subprocess.CalledProcessError as e:
            print("Compilation failed!")
            print(e.stderr)
            raise

    def solve(self, A, b):
        """
        Solves Ax = b using the C++ SVD backend.

        Args:
            A (np.ndarray): The matrix A (dense or sparse).
            b (np.ndarray): The vector b.

        Returns:
            np.ndarray: The solution vector x.
        """
        # 1. Write inputs to the format the C++ program expects
        self._write_matrix_A(A)
        self._write_vector_B(b)

        # 2. Run the executable
        if not os.path.exists(self.executable_path):
            raise FileNotFoundError(f"Executable {self.executable_path} not found. Did you run .compile()?")

        try:
            # We assume the C++ program runs in the current directory where files were written
            result = subprocess.run(
                [self.executable_path],
                capture_output=True,
                text=True,
                check=True
            )
            # Optional: Print C++ internal timing/logs if needed
            # print(result.stdout) 
        except subprocess.CalledProcessError as e:
            print(f"Execution Error: {e.stderr}")
            raise RuntimeError("C++ Executable crashed.")

        # 3. Read the result
        return self._read_vector_X()

    def _write_matrix_A(self, A):
        """Writes Matrix A to A.dat in Matrix Market Coordinate format."""
        A = np.array(A, dtype=np.float64)
        rows, cols = A.shape
        
        # Get non-zero elements
        # Note: The C++ reader expects 1-based indexing
        nz_rows, nz_cols = np.nonzero(A)
        count = len(nz_rows)

        with open(self.input_a, 'w') as f:
            # Header matching source [2]
            f.write("%%MatrixMarket matrix coordinate real general\n")
            f.write(f"{rows} {cols} {count}\n")
            
            for r, c in zip(nz_rows, nz_cols):
                val = A[r, c]
                # Write: row+1, col+1, value
                f.write(f"{r+1} {c+1} {val}\n")

    def _write_vector_B(self, b):
        """Writes Vector b to B.dat."""
        b = np.array(b, dtype=np.float64).flatten()
        size = len(b)
        # Treated as a column vector based on source [3]
        # Format: rows cols nonzeros (cols is 1 implies column vector logic in C++ parser)
        
        # We will write all entries, even zeros, to be safe, or just non-zeros
        nz_indices = np.nonzero(b)[0]
        count = len(nz_indices)

        with open(self.input_b, 'w') as f:
            f.write("%%MatrixMarket matrix coordinate real general\n")
            # The C++ parser logic checks if rows==1 or cols==1. 
            # We format as (Size) 1 (NonZeros)
            f.write(f"{size} 1 {count}\n")
            
            for idx in nz_indices:
                val = b[idx]
                # Format: row_idx column_idx value (column is always 1)
                f.write(f"{idx+1} 1 {val}\n")

    def _read_vector_X(self):
        """Reads X_out.dat generated by the C++ program."""
        if not os.path.exists(self.output_x):
            raise FileNotFoundError("Output file X_out.dat was not generated.")

        with open(self.output_x, 'r') as f:
            lines = f.readlines()

        # Parse header
        # The C++ output is slightly non-standard:
        # "%%MatrixMarket matrix array real general"
        # "1 size size"
        # "1 index value"
        
        # Skip comments
        data_lines = [l for l in lines if not l.startswith('%') and l.strip()]
        
        if not data_lines:
            return np.array([])

        # Read dimensions
        try:
            dims = data_lines[0].split()
            # The C++ writer outputs: 1 size size
            size = int(dims[1]) 
        except (IndexError, ValueError):
            raise ValueError("Malformed output file header.")

        x = np.zeros(size, dtype=np.float64)

        # Parse data
        # Starting from second line
        for line in data_lines[1:]:
            parts = line.split()
            if len(parts) < 3:
                continue
            # C++ writes: 1 index value
            # index is 1-based
            idx = int(parts[1]) - 1
            val = float(parts[2])
            
            if 0 <= idx < size:
                x[idx] = val

        return x

    def clean(self):
        """Removes the temporary .dat files."""
        for f in [self.input_a, self.input_b, self.output_x]:
            if os.path.exists(f):
                os.remove(f)

# Example Usage
if __name__ == "__main__":
    # Create wrapper instance
    solver = SVDWrapper()

    # 1. Compile the C++ code (requires Make and g++)
    try:
        solver.compile()
    except Exception as e:
        print("Skipping execution due to compilation failure.")
        exit(1)

    # 2. Define data in Python (Numpy)
    # Using the example data from the user's provided A.dat and B.dat
    A_matrix = np.array([
        [1.0, 1.0, 0.0, 3.0],
        [2.0, 1.0, -1.0, 1.0],
        [3.0, -1.0, -1.0, 2.0],
        [-1.0, 2.0, 3.0, -1.0],
        [-1.0, 2.0, 3.0, -1.0]
    ])

    b_vector = np.array([4.0, 1.0, -3.0, 4.0, 2.0])

    print("\n--- Python Inputs ---")
    print("Matrix A:\n", A_matrix)
    print("Vector b:\n", b_vector)

    # 3. Solve
    try:
        x_solution = solver.solve(A_matrix, b_vector)
        
        print("\n--- C++ SVD Result ---")
        print("Solution x:\n", x_solution)
        
        # Verification using Numpy's own Least Squares
        x_numpy, _, _, _ = np.linalg.lstsq(A_matrix, b_vector, rcond=None)
        print("\n--- Numpy Reference Check ---")
        print("Solution x (numpy.linalg.lstsq):\n", x_numpy)
        
        print("\nDifference:", np.linalg.norm(x_solution - x_numpy))

    except Exception as e:
        print(f"Error during solving: {e}")

    # 4. Clean up temporary files
    # solver.clean()
